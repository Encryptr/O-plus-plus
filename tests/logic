## Logic Tests

https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html


// Outer AND
// b = (a == 1 || a == 2) && a == 3;
// b = a == 1 && (a == 2 || a == 3);

// b = (a == 1 || a == 2)
//     && 
//     (a == 3 || a == 4);

// Outer OR
// b = (a == 1 && a == 2) || a == 3;
// b = a == 1 || (a == 3 && a == 4);

// b = (a == 1 && a == 2) || (a == 3 && a == 4);


/* Assigment Structure
	compare ...
.L0 # True
	mov eax, 1
	jmp .L2
.L1 # False 
	mov eax, 0
.L2 
	# End
*/

/* If Structure 
	compare ...
.L0
	# if body ...
	jmp .L2
.L1 
	# else body ...
.L2 
	# End
*/

/* ------------ Basics ------------ */
// Basic logic expr's 

/* | And |
LHS: Opposite -> False
RHS: Opposite -> False
*/
// b = a == 1 && a == 2;
// b = a > 1 && a < 2;

/* | Or |
LHS: Regular -> True
RHS: Opposite -> False
*/
// b = a == 1 || a == 2;
// b = a > 1 || a < 1;

/* ------------ Intermediate Single ------------ */
// More advanced logic expr's with same operator

/* 
LHS: Opposite -> False  
RHS: Opposite -> False 
RHS: Opposite -> False 
*/
// b = (a == 1 && a == 2) && a == 3;
// b = a == 1 && (a == 2 && a == 3);

/* 
LHS: Opposite -> False  
RHS: Opposite -> False 
LHS: Opposite -> False
RHS: Opposite -> False 
*/
// b = (a == 1 && a == 2) && (a == 3 && a == 4);

/* 
LHS: Regular -> True  
RHS: Regular -> True 
RHS: Opposite -> False 
*/
// b = (a == 1 || a == 2) || a == 3;
// b = a == 1 || (a == 2 || a == 3);

/* 
LHS: Regular -> True  
RHS: Regular -> True
LHS: Regular -> True
RHS: Opposite -> False
*/
// b = (a == 1 || a == 2) || (a == 3 || a == 4);

/* ------------ Intermediate Mixed ------------ */

/* 
LHS: Regular -> RHS  
RHS: Opposite -> False
RHS: Opposite -> False 
*/
// b = (a == 1 || a == 2) && a == 3;

/* 
LHS: Opposite -> False  
LHS: Regular -> True
RHS: Opposite -> False 
*/
// b = a == 1 && (a == 2 || a == 3);

/* 
LHS: Regular -> True  
RHS: Opposite -> False
LHS: Opposite -> False
*/
// b = a == 1 || (a == 3 && a == 4);

/* 
LHS: Opposite -> RHS  
RHS: Regular -> True
RHS: Opposite -> False
*/
// b = (a == 1 && a == 2) || a == 4;

// b = (a == 1 && a == 2) || (a == 3 && a == 4);
}

/* 
Logic:
If the left side of a logic AND/OR is also a logic AND/OR
follow these settings. The left left hand side of the AND/OR
should follow its operators pattern. However the right side of 
that expr should follow the parent operators left hand side pattern.
THIS only applies to if there is an AND/OR on the lhs of the already 
AND/OR. Another noticable change will be that this will cause an additional
label to need to be made. This in turn will make the left left hs jmp to the 
parents rhs expr. The right hand side of the parent operator shall follow its 
logical operators pattern on just eval the expr.

Extras:
** Right => right side, side of inner follows outer if there is any
** When right side of an outer || is also an || it shall follow the or's left hs pattern

LABEL STACK!! No however on the right track	# Look at label numbers for hints

into analize pass in two labels and make it so that the function can overload 
that label

this will eliminate the need for global jmp_locs. 

*** FOR JMP_LOCS NOTICE THE FALSE AND TRUE JUMPS!!! THEY FOLLOW A PATTERN 
*** ONLY SET FLAGS FOR ONCE LHS AND RHS ARE UNARY otherwise just set outer 

Needed:
	Since each call of the logic eval function needs to be independent a flag based
	system needs to be designed to allow for the ability to generate correct logic 
	expressions. ** All of these vars need to be saved at the beggining of the func
	and restored to their previous state at the end **

	- Deph
		This var will store the depth at which we are inside our logic expr. 
		This needs to be know when deciding what pattern to follow on the right 
		side of an AND/OR.
		
		Example:
			1 == 1 && ()

	- Lhs / Rhs label

	- AND/OR/OR Flag
		This variable will be storing the state of our current logic expression. It starts in
		its default state but can be set before calling the eval expression. This will let the 
		lhs expression know more about how it should generate code. 
		Cases:
			LHS_OP - This is letting know the currently evaluating lhs expression that if it is
			also a AND/OR expr its right side needs to follow the opposite logic expr pattern.
		Example: (ignore expr meaning)
			(1 == 1 && 2 == 2) || (3 == 3)
			The OR will be evaluated first causing the lhs and to follow the OR's pattern.
			Meaning the and will generate a jne followed by a je instead of the usual AND's 
			jne on both sides. 


Conclusion:
Several things will need to be known while compiling to achieve this. #1 during 
the evaultion of a AND/OR a check will need to be done on the lhs to see if it is
as well a AND/OR logical expr. If so a flag needs to be set letting know that the next
logical AND/OR we go into to eval shall follower its parents rule on the rhs.
*/










